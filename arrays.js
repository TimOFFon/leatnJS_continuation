/**
 * Array - особая структура данных / 
 * упорядоченная коллекция данных
 */

// два варианта синтаксиса для создания пустого массива:
let arr1 = new Array();
let arr2 = [];

// Элементы массива нумеруются, начиная с нуля.
let fruits = ["Яблоко", "Апельсин", "Слива"];
// console.log( fruits[0] ); // Яблоко
// console.log( fruits[1] ); // Апельсин
// console.log( fruits[2] ); // Слива

// можем заменить элемент:
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]

//обавить новый к существующему массиву:
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]

//Общее число элементов массива содержится в его свойстве length:
let fruits1 = ["Яблоко", "Апельсин", "Слива"];
// console.log( fruits.length ); // 3

// вывести массив целиком можно при помощи console.log()
// console.log(fruits);// Яблоко, Апельсин, Слива

//В массиве могут храниться элементы любого типа
// разные типы значений
let arr3 = [ 'Яблоко', { name: 'Джон' }, true, function() { console.log('привет'); } ];

// получить элемент с индексом 1 (объект) и затем показать его свойство
// console.log( arr3[1].name ); // Джон

// получить элемент с индексом 3 (функция) и выполнить её
// arr3[3](); // привет

//Список элементов массива, как и список свойств объекта, может оканчиваться запятой:
let fruits2 = [
    "Яблоко",
    "Апельсин",
    "Слива",
    ];


// ---------------------------------------------------
// Получение последних элементов при помощи «at»
/**
 * Некоторые языки программирования позволяют использовать
 * отрицательные индексы для той же цели, как-то так:
 * fruits[-1].
 * 
 * Однако, в JavaScript такая запись не сработает. Её
 * результатом будет undefined, поскольку индекс в
 * квадратных скобках понимается буквально.
 * 
 * Мы можем явно вычислить индекс последнего элемента, а
 * затем получить к нему доступ вот так: fruits[fruits
 * length - 1].
 */

let fruits3 = ["Apple", "Orange", "Plum"];
// console.log( fruits[fruits.length-1] ); // Plum

//есть более короткий синтаксис: fruits.at (-1)
let fruits4 = ["Apple", "Orange", "Plum"];
// console.log(fruits.at(-1));

/**
 * arr.at(i) при положительных значениях оступает
 * от НАЧАЛА
 * при отрицательных значениях от конца
 */

//-------------------------------------------------------
//    Методы pop/push, shift/unshift

//  unshift - ДОБАВЛЯЕТ в начало (возвращает новый length)
//  push - ДОБАВЛЯЕТ в конец (возвращает новый length)


//  shift - УДАЛЯЕТ у начала (и возвращает значение)
//  pop   - УДАЛЯЕТ с конца (и возвращает значение)


// Очередь - (push/shift) <--shift---[]<---push---
// Стек - (push/pop)   push ↓ pop ↑
// Двусторонняя очередь - (push/unshift/pop/shift)

// unshift/shift - МЕДЛЕННО (операции с началом)
// push/pop - БЫСТРО  (операции с концом)

// unshift (+0)
let arr4 = [1, 2];
arr4.unshift(3);
// console.log(arr4); // [3, 1, 2]

// push (0+)
let arr5 = [1, 2];
arr5.push(3);
// console.log(arr5); // [1, 2, 3]

// shift (-0)
let arr6 = [1, 2, 3];
arr6.shift();
// console.log(arr6); // [2, 3]

// pop (0-)
let arr7 = [1, 2, 3];
arr7.pop();
// console.log(arr7); // [1, 2]

//unshift и push могут добавлять несколько элементов:
let arrForUnshift = ["A", "B"];
arrForUnshift.unshift(1, 2);
// console.log(arrForUnshift); // [1, 2, 'A', 'B']

let arrForrPush = ['A', 'B'];
arrForrPush.push(1, 2);
// console.log(arrForrPush); // ['A', 'B', 1, 2]

//----------------------------------------------------
// Внутреннее устройство массива

/**
 * Массив – это особый подвид объектов.
 * 
 * Массивы расширяют объекты, так как предусматривают
 * специальные методы для работы с упорядоченными
 * коллекциями данных, а также свойство length. 
 * 
 * Следует помнить, что в JavaScript существует 8 основных
 * типов данных. 
 * 
 * Массив является объектом и, следовательно, ведёт себя
 * как объект.
 */

// Массив копируется по ссылке:
let arrSource = ['something'];
let arrCoppy = arrSource;
// console.log(arrSource === arrCoppy); //  true

arrCoppy.push('toBack');

// console.log(arrSource); //['something', 'toBack']

/**
 * Но если с массивом работать как с ОБЫЧНЫМ объектом,
 * и движок поймёт это, способы оптимизации, используемые
 * для массивов, будут отключены и никакой выгоды не
 * принесут.
 * 
 * Массив следует считать особой структурой, позволяющей
 * работать с упорядоченными данными. Для этого массивы
 * предоставляют специальные методы. Массивы тщательно
 * настроены в движках JavaScript для работы с однотипными
 * упорядоченными данными, поэтому, пожалуйста,
 * используйте их именно в таких случаях.
 */

//-------------------------------------------------------
//Варианты неправильного применения массива:

/**
 * Добавление нечислового свойства: arr.test = 5.
 * 
 * Создание «дыр»: добавление arr[0], затем arr[1000
 * (между ними ничего нет).
 * 
 * Заполнение 
 * в обратном порядке : arr[1000], arr[999] и т.д.
 */

//------------------------------------------------------
//  Эффективность

// unshift/shift - МЕДЛЕННО (операции с началом)
// push/pop - БЫСТРО  (операции с концом)

/**
 * При операциях с началом происходит пересчёт всей длинны
 * массива и переиндексация элементов.
 */

//------------------------------------------------------
//  Перебор элементов

// САМЫЙ оптимальный - for (по индексам, самый быстрый)
// ВОЗМОЖНЫЙ - for of (доступ только к значению, короткий)
// ПЛОХОЙ  - for in (переберает лишние свойства, медленный)

//------------------------------------------------------
// Немного о «length» (index + 1)

//автоматически обновляется при изменении массива

//length – можно перезаписать
let arrLength = [1, 2, 3, 4, 5]; // length = 5
arrLength.length = 3;
// console.log(arrLength); // [1, 2, 3]


//----------------------------------------------------
// new Array()

/**
 * Если new Array вызывается с одним аргументом, который
 * представляет собой число, он создаёт массив без
 * элементов, но с заданной длиной.
 */

//-----------------------------------------------------
// Многомерные массивы

let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

// console.log(matrix[1][1]);// 5

//-----------------------------------------------------
// toString

let arrToString = [1, 2, 3];
// console.log(String(arrToString)); // "1,2,3"

// console.log([] + 1 ); // "1"
// console.log([1] + 1 ); // "11"
// console.log([1,2] + 1 ); // "1,21" <--оператор запятая

/**
 * Массивы не имеют ни Symbol.toPrimitive, ни
 * функционирующего valueOf, они реализуют только
 * преобразование toString, таким образом, здесь []
 * становится пустой строкой, [1] становится "1", а [1,2]
 * становится "1,2".
 */

//бинарный оператор плюс "+" добавляет что-либо к строке
//он тоже преобразует это в строку
// console.log("" + 1 ); // "1"
// console.log("1" + 1 ); // "11"
// console.log("1,2" + 1 ); // "1,21"<--оператор запятая
// console.log(+[] + 1); // 1 <---унарный плюс в число

//-----------------------------------------------------
// Оператор ==

/**
 * Два объекта равны друг другу == только в том случае,
 * если они ссылаются на один и тот же объект.
 * 
 * Если один из аргументов == является объектом, а другой
 * – примитивом, то объект преобразуется в примитив.
 * 
 * …За исключением null и undefined, которые равны == друг
 * другу и ничему больше.
 */

/**
 * сравниваем массивы с помощью ==, то они никогда не
 * будут одинаковыми, если только мы не сравним две
 * переменные, которые ссылаются на один и тот же массив
 */

// console.log([] == [] ); // false
// console.log([0] == [0] ); // false
// Технически эти массивы являются разными объектами. 

//---------------------------------------------------
//Сравнение с примитивами 

//(массив (объект) преобразовывается в примитив (строку))

// console.log( 0 == [] ); // true (массив к пустой строке, 
// а оператор == к числу) (сначало в примитив, и в число)

// console.log('0' == [] ); // false (массив преаброзован к 
// пустой строке, а при оператор сравнения 
// к  0, а строка с нулём не пустая, не может
// преобразоваться к нулю)

// console.log('0' > [] ); // true (примитивы без преобр)

// console.log('0' == [0] ); // true (примитивы без преобр)






