// Методы массивов
//------------------------------------------------------


//---------------------------------------------------------
// Добавление/удаление элементов
/**
 * 
 * arr.push(...items) – добавляет элементы в конец,
 * arr.pop() – извлекает элемент из конца,
 * arr.shift() – извлекает элемент из начала,
 * arr.unshift(...items) – добавляет элементы в начало.
 * arr.splice((-)index[, deleteCount, elem1, ..., elemN])
 * arr.slice(-+[start], +-[end]) - новый массив в диапазоне
 * arr.concat(arg1, arg2...) - создаёт новый массив из коп
 * arr.fill(value, start, end) - заполняет массив
 *    повторяющимися value, начиная с индекса start до end
 * arr.copyWithin(target, start, end) – копирует свои
 *    элементы, начиная со start и заканчивая end,
 *    в собственную позицию target (перезаписывает
 *    существующие);
 * arr.flat(depth)/arr.flatMap(fn) создаёт новый плоский
 *    массив из многомерного массива;
 */

//------------------------------------------------------
//Перебор: forEach

/**
 * arr.forEach позволяет запускать функцию 
 * для каждого элемента
 * 
 * Возвращаемое значение: undefined
 */

let arr = [1, 2, 3];
let resultArr = [];

arr.forEach(function(item, index, array) {
    // ... делать что-то с item
    resultArr[index] = ++item; // например элемент + 1
    });

// console.log(resultArr);// [2, 3, 4]

//-----------------------------------------------------
//  Поиск в массиве

/**
 * arr.indexOf(item, from)  - ищет item, начиная с индекса
 *  from, и возвращает ПЕРВЫЙ индекс, в противном случае -1
 * 
 * arr.lastIndexOf(item, from)   –  то же самое, но ищет 
 *  справа налево
 * 
 * arr.includes(item, from)– ищет item, начиная с индекса
 *  from, и возвращает true, если поиск успешен, правильно
 *  обрабатывает NaN в отличие от indexOf/lastIndexOf
 * 
 * arr.find(function(item, index, array) {}) -  находит 
 *  объект с определённым условием;
 *  если true - возвращается текущий элемент и перебор 
 *  прерывается;
 *  если все итерации оказались ложными, возвращается 
 *  undefined;
 * 
 * arr.findIndex(fn) – по сути, то же самое, но возвращает
 *  индекс, на котором был найден элемент, а не сам 
 *  элемент, и -1, если ничего не найдено;
 * 
 * arr.filter(fn) - возвращает массив из всех подходящих 
 *  элементов; 
 *  если true - элемент добавляется к результату, и перебор
 *  продолжается;
 *  возвращается пустой массив в случае, если ничего не
 *  найдено;
 * 
 * arr.some(Fn) - вызывает переданную функцию callback
 *  один раз для каждого элемента,до тех пор, пока не
 *  найдёт такой, для которого callback вернёт истинное
 *  значение (значение, становящееся равным true при
 *  приведении его к типу Boolean).
 *  Если такой элемент найден, метод some() немедленно
 *  вернёт true
 * 
 * arr.every(fn) - проверяет, удовлетворяют ли все
 *  элементы массива условию, заданному в передаваемой
 *  функции. Вернёт true / false.
 */

//-------------------------------------------------------
// Преобразование массива

/**
 * arr.map(fn) - вызывает функцию для каждого элемента 
 *  массива и возвращает массив результатов 
 *  выполнения этой функции;
 * 
 *  arr.sort()  - сортирует массив на месте, 
 *  меняя в нём порядок элементов;
 *  По умолчанию элементы сортируются как строки.
 * 
 * arr.sort(Fn)  - элементы массива сортируются в
 *  соответствии с её возвращаемым значением.
 *  Если сравниваются два элемента a и b, то:
 * 
 *  меньше 0, сортировка поставит a по меньшему индексу,
 *  чем b, то есть, a идёт первым;
 * 
 *  вернёт 0, сортировка оставит a и b неизменными
 *  по отношению друг к другу, но отсортирует их по
 *  отношению ко всем другим элементам;
 * 
 *  больше 0, сортировка поставит b по меньшему индексу,
 *  чем a;
 */
//----------------------------------------------------
let arrSortFn = [5, 0, 2, 1, 3, 6, 4];

// console.log(arrSortFn.sort((a,b) => a - b));// ok     
// ожидаю 0,1,2,..

// console.log(arrSortFn.sort((a,b) => b - a));// ok     
// ожидаю 6,5,4,..

// console.log(arrSortFn.sort((a,b) => b - a).sort((a,b) => {
//     if(a || b > arrSortFn.length / 2) {
//         return a - b;
//     } 
// }));
//[1, 2, 3, 0, 4, 5, 6]
//-------------------------------------------------------
/**
 * Для многих алфавитов лучше использовать метод
 *  str.localeCompare, для правильной сортировки букв,
 *  таких как Ö.
 * 
 * arr.reverse - меняет на месте порядок элементов
 *  в arr на обратный
 * 
 * str.split(delim) - разбивает строку на массив по
 *  заданному разделителю delim;
 *  У метода split есть необязательный второй числовой
 *  аргумент – ограничение на количество элементов в
 *  массиве. Если их больше, чем указано, то остаток
 *  массива будет отброшен.
 * 
 * arr.join(glue) - создаёт строку из элементов arr,
 *  вставляя glue между ними;
 * 
 *  arr.reduce(Fn) - используются для вычисления какого-нибудь
 *  единого значения на основе всего массива;
 *  применяет функцию reducer к каждому элементу массива
 *  (слева-направо), возвращая одно результирующее
 *  значение;
 * 
 * arr.reduce(function(accumulator, item, index, array) {
 *         // ...
 *     }, [initial]);
 * 
 * accumulator – результат предыдущего вызова этой функции,
 *  равен initial при первом вызове (если передан initial),
 * 
 * item – очередной элемент массива,
 * index – его индекс,
 * array – сам массив.
 * 
 * arr.reduceRight работает аналогично, но проходит
 *  по массиву справа налево
 */

//-------------------------------------------------------
//-------------------------------------------------------
// Array.isArray (проверка на массив)

/**
 * Массивы не образуют отдельный тип языка.
 *  Они основаны на объектах.
 * 
 * Поэтому typeof не может отличить простой объект
 *  от массива:
 */

// console.log(typeof {}); // object
// console.log(typeof []); // тоже object

/**
 * для этого придумали специальный метод: 
 *  Array.isArray(value). Он возвращает true,
 *  если value массив, и false, если нет;
 */

// console.log(Array.isArray({})); // false
// console.log(Array.isArray([])); // true

//-------------------------------------------------------
//-------------------------------------------------------
// необязательный параметр thisArg

/**
 * find, filter, map, за исключением метода sort,
 *  принимают необязательный параметр thisArg
 * 
 * arr.find(func, thisArg);
 * arr.filter(func, thisArg);
 * arr.map(func, thisArg);
 * // ...
 * // thisArg - это необязательный последний аргумент
 * 
 * Значение параметра thisArg становится this для func
 */


