
//===================================================

//                       Map                        

//===================================================

/**
 *     Map - коллекция ключ/значение как объект
 *           позволяет использовать ключи любого типа
 */

/**
 *     new Map() - сздает коллекцию.
 * 
 *     map.set(key, value) - запись value по ключу key.
 * 
 *     map.get(key) - возвращает значение по ключу или
 *                    undefined
 * 
 *     map.has(key) - возвращает true если key 
 *                    присутсвует иначе false
 * 
 *     map.delete(key) - удаляет пару по ключу
 * 
 *     map.clear() - очищает коллекцию от всех пар.
 * 
 *     map.size - возвращает количество пар
 */

let map1 = new Map();

map1.set('1', 'str1'); // ключ - строка
map1.set(1, 'num'); // ключ - цифра
map1.set(true, 'bool1'); // ключ - буль

// console.log(map1.get(1)); // num        (стр. 34)
// console.log(map1.get('1')); // 'str1'   (стр. 33)
// console.log(map1.get(true)); // 'bool1' (стр. 35)
// console.log(map1.size); // 3


/**!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 *           НЕ ИСПОЛЬЗОВАТЬ ДОСТУП К ПАРАМ 
 * 
 *                     map[key]
 * 
 *           Только методы map:  set,  get    
 * 
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */




/**----------------------------------------------------
 *       Map - может использовать в качестве ключа 
 *                         Object
 * ----------------------------------------------------
 */

let john = {name: 'John'};

// сохраняем количество посещений для каждого 
// пользователя

let visitsCountPeople = new Map();

// используем объект как ключ записывая посещения
visitsCountPeople.set(john, 123);

// console.log(visitsCountPeople.get(john)); // 123

/**
 * Подобная операция не возможна с объектом как с 
 * структурой хранения.
 * Объект преобразует все ключи в строки и ключ в 
 * качестве объекта стал бы строкой "[object Object]"
 */



/**
 *   Map - сравнивает ключи также как и ===, но в 
 *   случае с Map,  NaN === NaN.
 *   Так что NaN в Map можно использовать в качесве
 *   ключа.
 */


/**
 *   Каждый вызов map.set возвращает объект map, так 
 *   что можно объеденить вызовы в цепочку.
 */

let map2 = new Map();

map2.set('2', 'str2')
    .set(2, 'num2')
    .set(false, 'boll2');

// console.log(map2); 
//   {'2' => 'str2', 2 => 'num2', false => 'boll2'}





//===================================================

//                    ПЕРЕБОР Map                      

//===================================================

//                    три метода

/**
 *      map.keys()   - возвращает итерируемый объект
 *                     по ключам.
 *  
 *      map.values() - возвращает итерируемый объект
 *                     по значениям.
 * 
 *     map.entries() - возвращает итерируемый объект 
 *                     по парам [ключ, значение].
 *                     Этот вариант используется по 
 *                     умолчанию в for..of
 */


let recipeMap = new Map([
    ['огурец', 500],
    ['помидор', 350],
    ['лук', 50]
]);




//------------ перебор по ключам ----------------

// for (let vegetable of recipeMap.keys()) {
//     console.log(vegetable); // огурец, помидор, лук
// }

// console.log(recipeMap.keys()); 
// MapIterator {'огурец', 'помидор', 'лук'}




//------------ перебор по значениям ----------------

// for(let amount of recipeMap.values()) {
//     console.log(amount); // 500, 350, 50
// }

// console.log(recipeMap.values());
//MapIterator {500, 350, 50}




//------- перебор в формате [ключ, значение]----------

// for(let entry of recipeMap) {
//     // то же самое, что и recipeMap.entries()
//     console.log(entry); // ['огурец', 500] и т.д.
// }

// console.log(recipeMap.entries());
//{'огурец' => 500, 'помидор' => 350, 'лук' => 50}



//===================================================
// в Map перебор происходит в том же порядке, в каком 
// происходило добавление элементов.
//===================================================



//===================================================
// Map имеет встроенный метод forEach, схожий со 
// встроенным методом массивов Array:
//===================================================

// выполняем функцию для каждой пары
// recipeMap.forEach((value, key, map) => {
//     console.log(`${key + '-Make'}: ${value *= 2}`);
// });
//          огурец-Make: 1000
//          помидор-Make: 700
//          лук-Make: 100







//===================================================

//                    Map из Object

//                    Object из Map

//===================================================

/**
 *   При создании Map мы можем указать массив 
 *   (или другой итерируемый объект)
 *   с парами ключ-значение для инициализации.
 */

// массив пар [ключ, значение]
let map3 = new Map([
    ['3', 'str3'],
    [3, 'num3'],
    [true, 'bool3'],
]);
// console.log(map3);
//Map(3) {'3' => 'str3', 3 => 'num3', true => 'bool3'}




//====================================================
//                 Map из Object
//====================================================

/**
 *      Object.entries(obj) - встроенный метод
 *                         получает объект и возвращает
 *                         массив пар ключ-значение.
 */

let obj4 = {
    name: "John",
    age: 30
};

let map4 = new Map(Object.entries(obj4));

// console.log(map4);
// Map(2) {'name' => 'John', 'age' => 30}
// console.log(map4.get('name')); // John

/**
 *     Object.entries(obj4) - возвращает массив пар
 *                           ключ-значение.
 */

// console.log(Object.entries(obj4));
// ['name', 'John'], ['age', 30]




//====================================================
//                 Object из Map  
//====================================================

/**
 *    Object.fromEntries(obj) - делает противоположное,
 *                           получив массив пар ключ-
 *                           значение, создает из них
 *                           объект:
 */

let basket = Object.fromEntries([
    ['banana', 1],
    ['orange', 2],
    ['meat', 4],
]);

// console.log(basket); // {banana: 1, orange: 2, meat: 4}
// console.log(basket.orange); // 2 (стр. 274)




//---------- Получаем обычный объект из Map -----------

let map5 = new Map();

map5.set('banana', 1)
    .set('orange', 2)
    .set('meat', 4)
    .set('apple', 10);

let obj5 = Object.fromEntries(map5);

// console.log(obj5);
//{banana: 1, orange: 2, meat: 4, apple: 10}





//===================================================

//                       Set                        

//===================================================

/**
 *    Set - коллекция УНИКАЛЬНЫХ значений БЕЗ КЛЮЧЕЙ
 *          (каждое значение  только один раз)
 */

/**
 *       new Set(iterable) - создаёт новый Set
 *                        если аргумент итерируемый объект
 *                        (массив), копирует УНИКАЛЬНЫЕ
 *                        значения в новый Set.
 * 
 *       set.add(value) - добавляет значение
 *                   (если оно уже есть, ничего не делает)
 *                   возвращает set.
 * 
 *       set.delete(value) - удаляет значение,
 *                        возвращает true, если value
 *                        было во множестве на момент 
 *                        вызова, иначе false.
 * 
 *       set.has(value) - возвращает true, если значение
 *                      value присутсвтует в множестве,
 *                      иначе false.
 * 
 *       set.clear() - удаляет все имеющиеся значения.
 * 
 *       set.size - возвращает колличество элементов в
 *                  множестве.
 */


/**
 *      Set - нужен для создания УНИКАЛЬНЫХ значений.
 *           Т.е при повторных вызовах set.add() с одним
 *           и тем же значением ничего не происходит.
 */

/**
 *     Например нам нужно создать список посетителей, и
 *     при повторных посещениях не вызыввать дубликаты.
 */

let set1 = new Set();

let kohn = {name: "Kohn"};
let peter = {name: "Peter"};
let sarah = {name: "Sarah"};

// считаем гостей, некоторые приходят несколько раз
set1.add(kohn);
set1.add(kohn);
set1.add(sarah);
set1.add(peter);
set1.add(peter);

// set хранит только 3 уникальных значения
// console.log(set1.size); // 3

for (let user of set1) {
    // console.log(user.name); // Kohn  Sarah  Peter
}

/**
 *   Если вместо Set использовать массив, то пришлось
 *   бы использовать дополнительную проверку на 
 *   УНИКАЛЬНОСТЬ с помощью arr.find, Set удобнее.
 */




//====================================================
//                 перебор Set  
//====================================================



/**-----------------------------------------------
 *          Перебор Set - с помощью 
 * 
 *           for..of   и   forEach 
 * ------------------------------------------------
 */

let set2 = new Set(['переговоры', 'санкции', 'уступки']);

for (let option of set2) {
    // console.log(option); //переговоры санкции уступки
}

// то же самое с forEach:
set2.forEach((option, optionAgain, set2) => {
    // console.log(option);//переговоры санкции уступки
});



/**
 *       forEach у Set имеет 3 аргумента.
 *     
 *         option, и снова optionAgain
 * 
 *         для совместимости с Map
 */

/**
 *       Set.keys() - возвращает перебираемый объект
 *                  для ЗНАЧЕНИЙ
 *     
 *       set.values() - то же самое, что и set.keys()
 *                        для совместимости с Map
 * 
 *       set.entries() - возвращает перебираемый объект
 *                       для ПАР вида [значение, значение]
 *                          для совместимости с Map
 */



